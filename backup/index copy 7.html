<!DOCTYPE html>
<html>
<head>
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<title></title>
	<script type='text/javascript' src="../lib/d3.js"></script>
	<script type='text/javascript' src="../lib/underscore.js"></script>
	<script type='text/javascript' src="keywords.js"></script>
<style>
	*{
		box-sizing: border-box;
	}
	div{
		border: 0px solid silver;
	}
	text {
		font: 24px "Helvetica Neue", Helvetica, Arial, sans-serif;
		text-anchor: middle;
		pointer-events: none;
	}
	circle {
		fill: #ccc;
	}
	.node:hover circle, .node.selected circle {
		stroke: black;
		stroke-width: 3px;
	}
	.top circle{
		fill: none;
		stroke: silver;
	}
	#outside-container{
		margin: 0 auto;
	}
	#legend{
		float: left;
		width: 400px;
	}
	#visu{
		float: left;
		width: 400px;
	}
</style>
</head>
<body>

<div id="outside-container">
	<div id="legend"></div>
	<div id="visu"></div>
	<div id="keyword"></div>
</div>

<script>

	var legendContainerSelector = '#legend';
	var visuContainerSelector = '#visu';

	var keywordsEntries = [];
	keywords.forEach(function(d, i){
		keywordsEntries.push({key: d.keyword, value: d.count, event: d.event});
	});

	var keywordContainer = d3.select('#keyword');

	// bubble chart
	var bleed = 10,
		width = 400,
		height = 400;

	var colors = d3.scale.category20c();

	var pack = d3.layout.pack()
		.sort(null)
		.size([width, height + bleed * 2])
		.padding(2)
		.value(function(d){return d.value; });

	function renderBubbles(_keywordsEntries, containerSelector, callback){

		var svg = d3.select(containerSelector + ' svg');
		if(!svg[0][0]){
			svg = d3.select(containerSelector).append("svg")
				.attr("width", width)
				.attr("height", height)
				.append("g")
				.attr("transform", "translate(0," + -bleed + ")");
		}

		var node = svg.selectAll("g")
			.data(pack.nodes({key: '', value: 1, children: _keywordsEntries}), function(d, i){ return (d && d.key) ? d.key : 'none'; });

		var nodeEnter = node.enter().append("g")
			.classed("node", function(d){ return d.depth > 0;})
			.classed("top", function(d){ return d.depth === 0;})
			.attr("transform", function(d) { return "translate(" + d.x + "," + d.y + ")"; });

		nodeEnter.append("circle")
			.style({opacity: 0})
			.attr("r", function(d) { return d.r; })
			.on('mouseenter', function(d, i){
				keywordContainer.html(d.key);
			})
			.on('click', function(d, i){
				callback(d, i);
			});
		nodeEnter.append("text")
			.attr({dy: ".35em"})
			.style({opacity: 0});

		var nodeTransition = node.transition().duration(500);
		nodeTransition.attr("transform", function(d) { return "translate(" + d.x + "," + d.y + ")"; });
		nodeTransition.selectAll("circle")
			.style({fill: function(d, i){
					if(d.depth === 0) return null;
					return colors(d.event);
				},
				opacity: 1
			})
			.attr("r", function(d){ return d.r; });
		node.selectAll('text')
			.filter(function(d){ return d.r > 10; })
			.text(function(d){ return d.key; })
			.style({'font-size': '24px'})
			.transition().duration(300)
			.style({'font-size': function(d){
					return Math.min(2 * d.r, (2 * d.r - 8) / this.getComputedTextLength() * 24) + "px";
				},
				opacity: 1
			});

		node.exit().transition().style({opacity: 0}).remove();
	}

	var legendSelected = null;
	function renderLegend(){
		var allEvents = keywordsEntries.map(function(d){ return d.event; });

		var eventCount = allEvents.reduce(function(pVal, val, i, arr){
			if(!pVal[val]){ pVal[val] = 0; }
			pVal[val]++;
			return pVal;
		}, {});
		var uniqueEvents = d3.entries(eventCount);
		uniqueEvents.forEach(function(d){ d.event = d.key; });

		var legendSelected = null;
		var callback = function(d, i){
			var event = uniqueEvents[i];
			if(event === legendSelected){
				legendSelected = null;
				renderBubbles(keywordsEntries, visuContainerSelector, callback);
			}
			else{
				legendSelected = event;
				var event = d.event;
				var keywordsEntriesFiltered = keywordsEntries.filter(function(d, i){ return d.event === event; });
				renderBubbles(keywordsEntriesFiltered, visuContainerSelector, callback);
			}
		};

		renderBubbles(uniqueEvents, legendContainerSelector, callback);
	}

	renderLegend();
	renderBubbles(keywordsEntries, visuContainerSelector);

</script>

</body>
</html>